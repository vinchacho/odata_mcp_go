# v1.6.3 Bug Fixes Design

**Status**: Implemented
**Author**: Claude + Vincent
**Date**: 2025-12-16
**Target Version**: v1.6.3

---

## Overview

v1.6.3 is a critical bug fix release addressing race conditions, panics, and metadata parsing issues discovered in production use.

---

## Fix 1: Race Condition in ODataClient

### Problem Statement

Concurrent requests cause data races when accessing shared state:
- CSRF token
- Session cookies
- Cookie map

Race detector (`go test -race`) flagged these issues.

### Root Cause

```go
// UNSAFE: No synchronization
c.csrfToken = newToken
c.sessionCookies = resp.Cookies()
```

### Solution

Add mutex guards for all shared state:

```go
type ODataClient struct {
    mu            sync.RWMutex
    csrfToken     string
    sessionCookies []*http.Cookie
    cookieMap     map[string]string
}

func (c *ODataClient) SetCSRFToken(token string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.csrfToken = token
}

func (c *ODataClient) GetCSRFToken() string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.csrfToken
}
```

### Files Changed

| File | Changes |
|------|---------|
| `internal/client/client.go` | Add mutex, use getters/setters |

### Acceptance Criteria

- [ ] `go test -race` passes
- [ ] Concurrent requests don't corrupt state
- [ ] No deadlocks under load

---

## Fix 2: Multiple EDMX Schemas Not Parsed

### Problem Statement

Some OData services (especially SAP) return multiple `<Schema>` blocks in `$metadata`. Only the first schema was being parsed, missing entity types from other schemas.

### Root Cause

```go
// WRONG: Only processes first schema
schema := edmx.DataServices.Schema[0]
```

### Solution

Iterate over all schema blocks:

```go
for _, schema := range edmx.DataServices.Schema {
    for _, entityType := range schema.EntityType {
        // Process entity type
    }
    for _, entitySet := range schema.EntityContainer.EntitySet {
        // Process entity set
    }
}
```

### Files Changed

| File | Changes |
|------|---------|
| `internal/metadata/parser.go` | Loop over all schemas |
| `internal/metadata/parser_v4.go` | Same for v4 |

### Acceptance Criteria

- [ ] All schema blocks processed
- [ ] Entity types from all namespaces available
- [ ] Cross-schema navigation properties resolved

---

## Fix 3: SSE Accept Header Check Too Strict

### Problem Statement

SSE transport rejects requests with combined Accept headers:

```
Accept: text/event-stream, application/json
```

This is valid per HTTP spec but our check required exact match.

### Root Cause

```go
// WRONG: Exact match required
if r.Header.Get("Accept") != "text/event-stream" {
    return error
}
```

### Solution

Check if `text/event-stream` is present anywhere in Accept header:

```go
accept := r.Header.Get("Accept")
if !strings.Contains(accept, "text/event-stream") {
    return error
}
```

### Files Changed

| File | Changes |
|------|---------|
| `internal/transport/sse.go` | Relax Accept header check |

### Acceptance Criteria

- [ ] Accept `text/event-stream` alone
- [ ] Accept `text/event-stream, application/json`
- [ ] Accept `*/*` (wildcard)
- [ ] Reject `application/json` alone

---

## Fix 4: Double-Close Panic in Streamable Transport

### Problem Statement

Closing a stream twice causes panic:

```
panic: close of closed channel
```

This happens when:
1. Request completes normally (closes channel)
2. Context cancellation triggers cleanup (tries to close again)

### Root Cause

```go
// WRONG: Can be called twice
close(stream.done)
```

### Solution

Use `sync.Once` to ensure exactly one close:

```go
type Stream struct {
    done     chan struct{}
    closeOnce sync.Once
}

func (s *Stream) Close() {
    s.closeOnce.Do(func() {
        close(s.done)
    })
}
```

### Files Changed

| File | Changes |
|------|---------|
| `internal/transport/streamable.go` | Add sync.Once for channel close |

### Acceptance Criteria

- [ ] No panic on double close
- [ ] Context cancellation handled gracefully
- [ ] Resources cleaned up properly

---

## Fix 5: Context Not Propagated to Tool Handlers

### Problem Statement

Tool handlers don't receive the HTTP request context, preventing:
- Request cancellation
- Timeout enforcement
- Tracing/observability

### Root Cause

```go
// WRONG: Using background context
result, err := handler(context.Background(), args)
```

### Solution

Pass request context through the call chain:

```go
// In HTTP handler
result, err := handler(r.Context(), args)
```

### Files Changed

| File | Changes |
|------|---------|
| `internal/mcp/server.go` | Propagate request context |
| `internal/transport/http.go` | Pass context to handlers |
| `internal/transport/streamable.go` | Pass context to handlers |

### Acceptance Criteria

- [ ] Client disconnect cancels in-flight requests
- [ ] HTTP timeouts enforced
- [ ] Context values available in handlers

---

## Fix 6: Concurrent ResponseWriter Writes

### Problem Statement

SSE transport has race condition when:
1. Main goroutine writes message
2. Keepalive goroutine writes ping

Both access `http.ResponseWriter` without synchronization.

### Root Cause

```go
// WRONG: No synchronization
go func() {
    for {
        w.Write([]byte(": ping\n\n"))  // Keepalive
    }
}()
w.Write([]byte("data: " + msg))  // Main message
```

### Solution

Add mutex for ResponseWriter access:

```go
type SSEWriter struct {
    mu sync.Mutex
    w  http.ResponseWriter
}

func (s *SSEWriter) Write(p []byte) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.w.Write(p)
}
```

### Files Changed

| File | Changes |
|------|---------|
| `internal/transport/sse.go` | Add mutex for writes |

### Acceptance Criteria

- [ ] No race detector warnings
- [ ] Messages not interleaved/corrupted
- [ ] Keepalives work correctly

---

## Fix 7: Non-Deterministic Composite Key Ordering

### Problem Statement

Composite keys generate different URL predicates across runs:

```
Run 1: /Entities(A='1',B='2')
Run 2: /Entities(B='2',A='1')
```

This breaks caching and testing.

### Root Cause

Go map iteration is non-deterministic:

```go
for k, v := range keyMap {  // Order varies!
    parts = append(parts, fmt.Sprintf("%s='%s'", k, v))
}
```

### Solution

Sort key names alphabetically before building URL:

```go
keys := make([]string, 0, len(keyMap))
for k := range keyMap {
    keys = append(keys, k)
}
sort.Strings(keys)

for _, k := range keys {
    parts = append(parts, fmt.Sprintf("%s='%s'", k, keyMap[k]))
}
```

### Files Changed

| File | Changes |
|------|---------|
| `internal/client/client.go` | Sort keys before URL construction |

### Acceptance Criteria

- [ ] URL predicates always in alphabetical order
- [ ] Same entity always gets same URL
- [ ] Tests pass deterministically

---

## Fix 8: Deprecated io/ioutil Usage

### Problem Statement

`io/ioutil` package is deprecated since Go 1.16:

```go
// DEPRECATED
import "io/ioutil"
body, _ := ioutil.ReadAll(r.Body)
```

### Solution

Replace with `io` package:

```go
import "io"
body, _ := io.ReadAll(r.Body)
```

### Files Changed

| File | Changes |
|------|---------|
| `internal/mcp/server.go` | Replace io/ioutil with io |

### Acceptance Criteria

- [ ] No deprecation warnings
- [ ] `go vet` passes

---

## Fix 9: Metadata Parse Failures Silently Ignored

### Problem Statement

When metadata parsing fails, empty metadata is used silently. User sees no tools and doesn't know why.

### Root Cause

```go
// WRONG: Swallows error
metadata, err := parser.Parse(data)
if err != nil {
    metadata = &Metadata{}  // Silent fallback
}
```

### Solution

Propagate error to user:

```go
metadata, err := parser.Parse(data)
if err != nil {
    return fmt.Errorf("failed to parse metadata: %w", err)
}
```

### Files Changed

| File | Changes |
|------|---------|
| `internal/bridge/bridge.go` | Return error instead of empty fallback |

### Acceptance Criteria

- [ ] Parse errors reported to user
- [ ] Clear error message includes parse details
- [ ] Startup fails fast on bad metadata

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Mutex causes deadlock | Low | High | Use RWMutex, keep critical sections small |
| Breaking change in metadata parsing | Low | Medium | Test against real SAP services |
| Context propagation breaks existing code | Low | Low | Only adds functionality |

---

## Testing Strategy

```bash
# Race detection
go test -race ./...

# Specific tests for each fix
go test -run TestConcurrentCSRF ./internal/client/
go test -run TestMultipleSchemas ./internal/metadata/
go test -run TestCompositeKeyOrder ./internal/client/
```
